<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="basics.css" type="text/css"></link>
    <script type="text/javascript" src="lib/paper-full.js"></script>
  </head>
  <body>
    <h1>A Path, in Parts.</h1>
    <section>
      <canvas id="paper-canvas" width="640" height="800" keepalive="true"></canvas>
    </section>
  </body>
  <script type="text/javascript">
    paper.setup(document.getElementById("paper-canvas"));


    var path,
        movingPath,
        bubblePath,
        smoothedPath,
        wigglePath,
        samplePaths = [];

    function addSamplePath(path, label, y) {
      var text = new paper.PointText(path.lastSegment.point.add([10, 0])),
          group = new paper.Group(text, path);

      text.content = label;
      text.fillColor = "#333";
      path.fullySelected = true;
      group.applyMatrix = false;
      group.translate([10, y]);

      samplePaths.push(path);
    }

    // Return a function that will oscillate a path the given amount.
    function createPointOscillation(amount) {
      amount = amount || 50.0;
      return function (path, t) {
        path.segments[1].point.y = Math.sin(t) * amount;
      }
    }

    // Return a function that will rotate a path's handles the given amount.
    function createHandleRotation(radius) {
      radius = radius || 50.0;
      return function (path, t) {
        var middle = path.segments[1];
        middle.handleIn = [Math.cos(t) * radius, Math.sin(t) * radius];
        middle.handleOut = [Math.sin(t - Math.PI / 2) * radius, - Math.cos(t - Math.PI / 2) * radius];
      }
    }

    // Linear mix of a and b. Expects t in range [0, 1].
    function mix(a, b, t) {
      return (1.0 - t) * a + t * b;
    }

    function createHueCycle(begin, end) {
      begin = begin || 0;
      end = end || 0;
      return function (path, t) {
        var t = (Math.cos(t) * 0.5 + 0.5);
        path.strokeColor.saturation = 1.0;
        path.strokeColor.brightness = 0.9;
        path.strokeColor.hue = mix(begin, end, t);
      }
    }

    path = new paper.Path();
    path.strokeWidth = 5.0;
    path.strokeColor = "#333";
    path.fullySelected = true;
    path.add([0, 0], [160, 0], [320, 0]);
    path.data.update = null;
    addSamplePath(path, "Basic Path. Made from three points (segments).", 100);

    movingPath = path.clone();
    movingPath.data.update = createPointOscillation(50.0);
    addSamplePath(movingPath, "Basic Path, animating segment position.", 200);

    // Paper can auto-smooth paths by adjusting their control handles.
    smoothedPath = path.clone();
    smoothedPath.smooth();
    var oscillate = createPointOscillation(50.0);
    smoothedPath.data.update = function (path, t) {
      oscillate(path, t);
      path.smooth();
    };
    addSamplePath(smoothedPath, "Animating segment position and using smooth().", 300);

    // We can adjust the control handles ourselves to get results we like.
    bubblePath = path.clone();
    var middle = bubblePath.segments[1];
    middle.handleIn = [-100, 0];
    middle.handleOut = [100, 0];
    bubblePath.data.update = createPointOscillation(50.0);
    addSamplePath(bubblePath, "Custom (static) Handles, animating segment position.", 400);

    wigglePath = path.clone();
    wigglePath.data.update = createHandleRotation(100.0);
    addSamplePath(wigglePath, "Animated Handles. Static segments positions.", 550);

    paper.view.draw();
    paper.view.onFrame = function (event) {
      var t = event.time * 2.2;
      samplePaths.forEach(function (path) {
        if(typeof path.data.update === "function") {
          path.data.update(path, t);
        }
      });
    }
  </script>
</html>
